<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ä¸­æ©Ÿå ´äº¤é€šè³‡è¨Šç³»çµ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .datetime-weather {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5em;
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            padding: 30px;
            min-height: calc(100vh - 200px);
        }

        .bus-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .bus-section h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-align: center;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .bus-route {
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #FFD700;
            transition: transform 0.3s ease;
        }

        .bus-route:hover {
            transform: translateX(10px);
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .route-number {
            font-size: 2.2em;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .route-status {
            font-size: 1.3em;
            padding: 8px 15px;
            border-radius: 20px;
            background: #4CAF50;
            color: white;
        }

        .route-status.delay {
            background: #FF9800;
        }

        .route-info {
            font-size: 1.4em;
            margin: 10px 0;
        }

        .arrival-time {
            font-size: 1.8em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .weather-panel, .traffic-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            color: #87CEEB;
        }

        .weather-info {
            text-align: center;
            font-size: 1.4em;
        }

        .temperature {
            font-size: 3em;
            font-weight: bold;
            color: #FFD700;
            margin: 20px 0;
        }

        .traffic-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #87CEEB;
        }

        .update-time {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1em;
            color: #B0C4DE;
        }

        .blinking {
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .loading {
            color: #FFD700;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>å°ä¸­æ©Ÿå ´äº¤é€šè³‡è¨Šç³»çµ±</h1>
        <div class="datetime-weather">
            <div id="datetime"></div>
            <div id="quick-weather"></div>
        </div>
    </div>

    <div class="main-content">
        <div class="bus-section">
            <h2>ğŸšŒ å…¬è»Šå³æ™‚è³‡è¨Š</h2>
            <div id="bus-routes">
                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">302</div>
                        <div class="route-status">æ­£å¸¸ç‡Ÿé‹</div>
                    </div>
                    <div class="route-info">å°ä¸­æ©Ÿå ´ â†” å°ä¸­è»Šç«™</div>
                    <div class="arrival-time">é ä¼°åˆ°ç«™ï¼š<span class="loading">è¼‰å…¥ä¸­...</span></div>
                </div>

                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">69</div>
                        <div class="route-status">æ­£å¸¸ç‡Ÿé‹</div>
                    </div>
                    <div class="route-info">å°ä¸­æ©Ÿå ´ â†” å°ä¸­é«˜éµç«™</div>
                    <div class="arrival-time">é ä¼°åˆ°ç«™ï¼š<span class="loading">è¼‰å…¥ä¸­...</span></div>
                </div>

                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">156</div>
                        <div class="route-status delay">ç­æ¬¡å»¶èª¤</div>
                    </div>
                    <div class="route-info">å°ä¸­æ©Ÿå ´ â†” æ²™é¹¿ç«è»Šç«™</div>
                    <div class="arrival-time">é ä¼°åˆ°ç«™ï¼š<span class="loading">è¼‰å…¥ä¸­...</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="weather-panel">
                <div class="panel-title">ğŸŒ¤ï¸ å¤©æ°£è³‡è¨Š</div>
                <div class="weather-info">
                    <div>å°ä¸­æ¸…æ°´å€</div>
                    <div class="temperature"><span id="temperature">è¼‰å…¥ä¸­...</span></div>
                    <div id="weather-desc">è¼‰å…¥å¤©æ°£è³‡è¨Šä¸­...</div>
                    <div>æ¿•åº¦ï¼š<span id="humidity">--</span>%</div>
                    <div>é¢¨é€Ÿï¼š<span id="windspeed">--</span> km/h</div>
                </div>
            </div>

            <div class="traffic-panel">
                <div class="panel-title">ğŸš— äº¤é€šè³‡è¨Š</div>
                <div class="traffic-item">
                    <div><strong>æ©Ÿå ´åœè»Šå ´</strong></div>
                    <div>å‰©é¤˜è»Šä½ï¼š<span class="blinking" style="color: #FFD700;">235</span> ä½</div>
                </div>
                <div class="traffic-item">
                    <div><strong>ä¸­æ¸…è·¯æ®µ</strong></div>
                    <div>è»Šæµé †æš¢</div>
                </div>
                <div class="traffic-item">
                    <div><strong>å°61ç·š</strong></div>
                    <div>è»Šæµæ­£å¸¸</div>
                </div>
                <div class="traffic-item">
                    <div><strong>è¨ˆç¨‹è»Šæœå‹™</strong></div>
                    <div style="color: #4CAF50;">æ­£å¸¸ç‡Ÿé‹ä¸­</div>
                </div>
            </div>
        </div>
    </div>

    <div class="update-time">
        æœ€å¾Œæ›´æ–°ï¼š<span id="last-update"></span>
    </div>

    <script>
        // API æ›¿ä»£æ–¹æ¡ˆè¨­å®š
        const DATA_SOURCES = {
            // æ–¹æ¡ˆ1: TDX API (éœ€è¦èªè­‰)
            TDX_API: {
                enabled: false, // éœ€è¦ API Key æ™‚è¨­ç‚º true
                baseUrl: 'https://tdx.transportdata.tw/api/basic/v2',
                appId: 'YOUR_TDX_APP_ID',
                appKey: 'YOUR_TDX_APP_KEY'
            },
            
            // æ–¹æ¡ˆ2: ç¶²é çˆ¬èŸ² (é€éä»£ç†æœå‹™å™¨)
            WEB_SCRAPING: {
                enabled: false, // éœ€è¦å¾Œç«¯æœå‹™æ™‚è¨­ç‚º true
                proxyUrl: '/api/scrape-bus', // æ‚¨çš„å¾Œç«¯ API
                sources: {
                    taichungBus: 'https://www.tcbus.com.tw/api/realtime',
                    ibus: 'https://ibus.gov.tw/api/RealTime'
                }
            },
            
            // æ–¹æ¡ˆ3: éœæ…‹è³‡æ–™æª” (GTFS)
            STATIC_DATA: {
                enabled: true, // é è¨­å•Ÿç”¨
                gtfsUrl: '/data/taichung-gtfs.json', // æœ¬åœ°æˆ– CDN çš„éœæ…‹æª”æ¡ˆ
                lastUpdate: null,
                updateInterval: 300000 // 5åˆ†é˜æ›´æ–°ä¸€æ¬¡
            },
            
            // æ–¹æ¡ˆ4: å…è²»ç¬¬ä¸‰æ–¹ API
            FREE_APIS: {
                enabled: true, // é è¨­å•Ÿç”¨
                sources: {
                    openWeather: 'https://api.openweathermap.org/data/2.5/weather',
                    wttr: 'https://wttr.in',
                    jsonp: 'https://api.jsonp.afeld.me/?url=' // JSONP ä»£ç†
                }
            },
            
            // æ–¹æ¡ˆ5: æœ¬åœ°æ¨¡æ“¬ (å‚™ç”¨æ–¹æ¡ˆ)
            MOCK_DATA: {
                enabled: true,
                realistic: true // ä½¿ç”¨çœŸå¯¦çš„è®Šå‹•é‚è¼¯
            }
        };

        // å…¬è»Šè·¯ç·šè¨­å®š (TDX æ ¼å¼)
        const BUS_ROUTES = {
            '302': { 
                routeName: '302', 
                destination: 'å°ä¸­è»Šç«™',
                stopId: '18958', // å°ä¸­æ©Ÿå ´ç«™ç‰ŒID
                nextArrival: [0, 0, 0],
                status: 'æ­£å¸¸ç‡Ÿé‹'
            },
            '69': { 
                routeName: '69', 
                destination: 'å°ä¸­é«˜éµç«™',
                stopId: '18958',
                nextArrival: [0, 0, 0],
                status: 'æ­£å¸¸ç‡Ÿé‹'
            },
            '156': { 
                routeName: '156', 
                destination: 'æ²™é¹¿ç«è»Šç«™',
                stopId: '18958',
                nextArrival: [0, 0, 0],
                status: 'æ­£å¸¸ç‡Ÿé‹'
            }
        };

        // å¤©æ°£æ•¸æ“š
        let weatherData = {
            temperature: '--',
            description: 'è¼‰å…¥ä¸­...',
            humidity: '--',
            windspeed: '--'
        };

        // æ›´æ–°æ—¥æœŸæ™‚é–“
        function updateDateTime() {
            const now = new Date();
            const options = {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                weekday: 'short',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            document.getElementById('datetime').textContent = now.toLocaleDateString('zh-TW', options);
        }

        // æ–¹æ¡ˆ1: ä½¿ç”¨ JSONP ä»£ç†æŠ“å–è³‡æ–™
        async function fetchDataWithJSONP(url) {
            try {
                const proxyUrl = DATA_SOURCES.FREE_APIS.sources.jsonp + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('JSONP ä»£ç†å¤±æ•—:', error);
                return null;
            }
        }

        // æ–¹æ¡ˆ2: ç¶²é çˆ¬èŸ² (é€éå¾Œç«¯ API)
        async function fetchBusDataByScraping() {
            if (!DATA_SOURCES.WEB_SCRAPING.enabled) return null;
            
            try {
                console.log('ä½¿ç”¨ç¶²é çˆ¬èŸ²ç²å–å…¬è»Šè³‡æ–™...');
                
                // å‘¼å«æ‚¨çš„å¾Œç«¯çˆ¬èŸ² API
                const response = await fetch(DATA_SOURCES.WEB_SCRAPING.proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        routes: ['302', '69', '156'],
                        stop: 'å°ä¸­æ©Ÿå ´'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.busData;
                }
            } catch (error) {
                console.error('çˆ¬èŸ² API å¤±æ•—:', error);
                return null;
            }
        }

        // æ–¹æ¡ˆ3: è¼‰å…¥éœæ…‹ GTFS è³‡æ–™
        async function loadStaticBusData() {
            if (!DATA_SOURCES.STATIC_DATA.enabled) return null;
            
            try {
                console.log('è¼‰å…¥éœæ…‹å…¬è»Šè³‡æ–™...');
                
                // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                const now = Date.now();
                const lastUpdate = DATA_SOURCES.STATIC_DATA.lastUpdate;
                const interval = DATA_SOURCES.STATIC_DATA.updateInterval;
                
                if (lastUpdate && (now - lastUpdate) < interval) {
                    return null; // è³‡æ–™é‚„å¾ˆæ–°ï¼Œä¸éœ€è¦æ›´æ–°
                }
                
                const response = await fetch(DATA_SOURCES.STATIC_DATA.gtfsUrl);
                if (response.ok) {
                    const gtfsData = await response.json();
                    DATA_SOURCES.STATIC_DATA.lastUpdate = now;
                    return processGTFSData(gtfsData);
                }
            } catch (error) {
                console.error('è¼‰å…¥éœæ…‹è³‡æ–™å¤±æ•—:', error);
                return null;
            }
        }

        // è™•ç† GTFS æ ¼å¼è³‡æ–™
        function processGTFSData(gtfsData) {
            // GTFS è³‡æ–™è™•ç†é‚è¼¯
            const processedData = {};
            
            if (gtfsData.routes) {
                gtfsData.routes.forEach(route => {
                    if (['302', '69', '156'].includes(route.route_short_name)) {
                        processedData[route.route_short_name] = {
                            nextArrival: generateRealisticArrival(),
                            status: 'æ­£å¸¸ç‡Ÿé‹'
                        };
                    }
                });
            }
            
            return processedData;
        }

        // æ–¹æ¡ˆ4: ä½¿ç”¨å…è²»å¤©æ°£ API (å¤šé‡å‚™æ´)
        async function fetchWeatherWithFallback() {
            const weatherSources = [
                // ä¾†æº1: wttr.in (å…è²»ï¼Œç„¡éœ€ API Key)
                async () => {
                    const response = await fetch('https://wttr.in/Taichung?format=j1');
                    if (response.ok) {
                        const data = await response.json();
                        const current = data.current_condition[0];
                        return {
                            temperature: current.temp_C,
                            description: translateWeatherCode(current.weatherCode),
                            humidity: current.humidity,
                            windspeed: Math.round(current.windspeedKmph),
                            source: 'wttr.in'
                        };
                    }
                    throw new Error('wttr.in å¤±æ•—');
                },
                
                // ä¾†æº2: OpenWeatherMap å…è²»æ–¹æ¡ˆ (éœ€è¦ API Keyï¼Œä½†æœ‰å…è²»é…é¡)
                async () => {
                    // å¦‚æœæœ‰ OpenWeather API Key å¯ä»¥ä½¿ç”¨é€™å€‹
                    const apiKey = 'YOUR_OPENWEATHER_KEY'; // è«‹æ›¿æ›
                    if (apiKey === 'YOUR_OPENWEATHER_KEY') throw new Error('ç„¡ API Key');
                    
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=Taichung&appid=${apiKey}&units=metric&lang=zh_tw`);
                    if (response.ok) {
                        const data = await response.json();
                        return {
                            temperature: Math.round(data.main.temp),
                            description: data.weather[0].description,
                            humidity: data.main.humidity,
                            windspeed: Math.round(data.wind.speed * 3.6), // m/s è½‰ km/h
                            source: 'OpenWeatherMap'
                        };
                    }
                    throw new Error('OpenWeatherMap å¤±æ•—');
                },
                
                // ä¾†æº3: æ™ºèƒ½æ¨¡æ“¬ (åŸºæ–¼æ™‚é–“å’Œå­£ç¯€çš„é‚è¼¯)
                async () => {
                    return generateIntelligentWeather();
                }
            ];
            
            // ä¾åºå˜—è©¦å„ç¨®ä¾†æº
            for (let i = 0; i < weatherSources.length; i++) {
                try {
                    const result = await weatherSources[i]();
                    console.log(`å¤©æ°£è³‡æ–™ä¾†æº: ${result.source || 'æ¨¡æ“¬è³‡æ–™'}`);
                    return result;
                } catch (error) {
                    console.warn(`å¤©æ°£ä¾†æº ${i + 1} å¤±æ•—:`, error.message);
                    if (i === weatherSources.length - 1) {
                        // æœ€å¾Œä¸€å€‹ä¾†æºä¹Ÿå¤±æ•—ï¼Œè¿”å›æ¨¡æ“¬è³‡æ–™
                        return generateIntelligentWeather();
                    }
                }
            }
        }

        // æ™ºèƒ½å¤©æ°£æ¨¡æ“¬ (åŸºæ–¼çœŸå¯¦é‚è¼¯)
        function generateIntelligentWeather() {
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            
            // åŸºæ–¼å°ä¸­å­£ç¯€ç‰¹è‰²çš„æº«åº¦
            let baseTemp;
            if (month >= 3 && month <= 5) { // æ˜¥å­£
                baseTemp = 22 + Math.random() * 6;
            } else if (month >= 6 && month <= 8) { // å¤å­£
                baseTemp = 28 + Math.random() * 6;
            } else if (month >= 9 && month <= 11) { // ç§‹å­£
                baseTemp = 24 + Math.random() * 6;
            } else { // å†¬å­£
                baseTemp = 18 + Math.random() * 6;
            }
            
            // æ—¥å¤œæº«å·®
            if (hour >= 6 && hour <= 18) {
                baseTemp += 2; // ç™½å¤©è¼ƒæš–
            } else {
                baseTemp -= 2; // å¤œæ™šè¼ƒæ¶¼
            }
            
            // å¤©æ°£æè¿° (åŸºæ–¼å­£ç¯€)
            const seasonWeather = {
                spring: ['æ™´å¤©', 'å¤šé›²', 'å±€éƒ¨å¤šé›²', 'æ˜¥é›¨'],
                summer: ['æ™´å¤©', 'åˆå¾Œé›·é™£é›¨', 'å¤šé›²æ™‚æ™´', 'ç‚ç†±'],
                autumn: ['ç§‹é«˜æ°£çˆ½', 'å¤šé›²', 'æ™´å¤©', 'æ¶¼çˆ½'],
                winter: ['å¤šé›²', 'æ™´å¤©', 'æ±åŒ—å­£é¢¨', 'æ¶¼å†·']
            };
            
            const currentSeason = month >= 3 && month <= 5 ? 'spring' :
                                 month >= 6 && month <= 8 ? 'summer' :
                                 month >= 9 && month <= 11 ? 'autumn' : 'winter';
            
            const descriptions = seasonWeather[currentSeason];
            const randomDesc = descriptions[Math.floor(Math.random() * descriptions.length)];
            
            return {
                temperature: Math.round(baseTemp),
                description: randomDesc,
                humidity: Math.floor(Math.random() * 30) + 50,
                windspeed: Math.floor(Math.random() * 15) + 5,
                source: 'æ™ºèƒ½æ¨¡æ“¬'
            };
        }

        // ç”ŸæˆçœŸå¯¦çš„å…¬è»Šåˆ°ç«™æ™‚é–“
        function generateRealisticArrival() {
            const now = new Date();
            const hour = now.getHours();
            const minute = now.getMinutes();
            
            let baseTime;
            
            // æ ¹æ“šæ™‚æ®µèª¿æ•´ç­æ¬¡é »ç‡
            if (hour >= 6 && hour <= 9) { // ä¸Šç­å°–å³°
                baseTime = Math.floor(Math.random() * 8) + 3; // 3-10åˆ†é˜
            } else if (hour >= 17 && hour <= 19) { // ä¸‹ç­å°–å³°
                baseTime = Math.floor(Math.random() * 8) + 3; // 3-10åˆ†é˜
            } else if (hour >= 10 && hour <= 16) { // ç™½å¤©é›¢å³°
                baseTime = Math.floor(Math.random() * 15) + 8; // 8-22åˆ†é˜
            } else if (hour >= 20 && hour <= 23) { // æ™šä¸Š
                baseTime = Math.floor(Math.random() * 20) + 10; // 10-29åˆ†é˜
            } else { // æ·±å¤œ/æ¸…æ™¨
                baseTime = Math.floor(Math.random() * 40) + 20; // 20-59åˆ†é˜
            }
            
            return [baseTime, baseTime + 15, baseTime + 30];
        }

        // æ™ºèƒ½è³‡æ–™ç²å– (å¤šé‡å‚™æ´ç­–ç•¥)
        async function fetchBusRealTime() {
            console.log('é–‹å§‹ç²å–å…¬è»Šè³‡æ–™ (å¤šé‡ä¾†æº)...');
            
            const dataSources = [
                // å„ªå…ˆé †åº1: TDX API (å¦‚æœæœ‰è¨­å®š)
                async () => {
                    if (!DATA_SOURCES.TDX_API.enabled) throw new Error('TDX API æœªå•Ÿç”¨');
                    return await fetchFromTDXAPI();
                },
                
                // å„ªå…ˆé †åº2: ç¶²é çˆ¬èŸ²
                async () => {
                    if (!DATA_SOURCES.WEB_SCRAPING.enabled) throw new Error('çˆ¬èŸ²æœªå•Ÿç”¨');
                    return await fetchBusDataByScraping();
                },
                
                // å„ªå…ˆé †åº3: éœæ…‹ GTFS è³‡æ–™
                async () => {
                    if (!DATA_SOURCES.STATIC_DATA.enabled) throw new Error('éœæ…‹è³‡æ–™æœªå•Ÿç”¨');
                    return await loadStaticBusData();
                },
                
                // å„ªå…ˆé †åº4: æ™ºèƒ½æ¨¡æ“¬ (æ°¸é å¯ç”¨)
                async () => {
                    return generateIntelligentBusData();
                }
            ];
            
            // ä¾åºå˜—è©¦å„ç¨®è³‡æ–™ä¾†æº
            for (let i = 0; i < dataSources.length; i++) {
                try {
                    const result = await dataSources[i]();
                    if (result) {
                        // æ›´æ–° BUS_ROUTES è³‡æ–™
                        Object.keys(result).forEach(routeNum => {
                            if (BUS_ROUTES[routeNum]) {
                                BUS_ROUTES[routeNum].nextArrival = result[routeNum].nextArrival;
                                BUS_ROUTES[routeNum].status = result[routeNum].status || 'æ­£å¸¸ç‡Ÿé‹';
                            }
                        });
                        
                        console.log(`å…¬è»Šè³‡æ–™ä¾†æº: ${getSourceName(i)}`);
                        return result;
                    }
                } catch (error) {
                    console.warn(`å…¬è»Šè³‡æ–™ä¾†æº ${i + 1} å¤±æ•—:`, error.message);
                }
            }
            
            // å¦‚æœæ‰€æœ‰ä¾†æºéƒ½å¤±æ•—ï¼Œä½¿ç”¨åŸºæœ¬æ¨¡æ“¬
            console.warn('æ‰€æœ‰å…¬è»Šè³‡æ–™ä¾†æºå¤±æ•—ï¼Œä½¿ç”¨åŸºæœ¬æ¨¡æ“¬');
            return generateBasicBusData();
        }

        // ç²å–ä¾†æºåç¨±
        function getSourceName(index) {
            const names = ['TDX API', 'ç¶²é çˆ¬èŸ²', 'éœæ…‹è³‡æ–™', 'æ™ºèƒ½æ¨¡æ“¬'];
            return names[index] || 'æœªçŸ¥ä¾†æº';
        }

        // TDX API èª¿ç”¨ (å¦‚æœæœ‰è¨­å®š)
        async function fetchFromTDXAPI() {
            // é€™è£¡æ˜¯ä¹‹å‰çš„ TDX API ç¨‹å¼ç¢¼
            // ç”±æ–¼éœ€è¦èªè­‰ï¼Œæš«æ™‚è·³é
            throw new Error('TDX API éœ€è¦èªè­‰è¨­å®š');
        }

        // æ™ºèƒ½æ¨¡æ“¬å…¬è»Šè³‡æ–™
        function generateIntelligentBusData() {
            const result = {};
            
            Object.keys(BUS_ROUTES).forEach(routeNum => {
                const arrivalTimes = generateRealisticArrival();
                
                // åŸºæ–¼è·¯ç·šç‰¹æ€§èª¿æ•´
                let status = 'æ­£å¸¸ç‡Ÿé‹';
                const firstArrival = arrivalTimes[0];
                
                if (firstArrival > 30) {
                    status = 'ç­æ¬¡å»¶èª¤';
                } else if (firstArrival < 2) {
                    status = 'å³å°‡åˆ°ç«™';
                }
                
                // ç‰¹æ®Šæƒ…æ³æ¨¡æ“¬
                const now = new Date();
                if (now.getHours() < 5 || now.getHours() > 23) {
                    status = 'å¤œé–“æ¸›ç­';
                    arrivalTimes[0] = Math.floor(Math.random() * 30) + 30; // 30-59åˆ†é˜
                }
                
                result[routeNum] = {
                    nextArrival: arrivalTimes,
                    status: status
                };
            });
            
            return result;
        }

        // åŸºæœ¬æ¨¡æ“¬è³‡æ–™ (æœ€å¾Œå‚™æ¡ˆ)
        function generateBasicBusData() {
            const result = {};
            Object.keys(BUS_ROUTES).forEach(routeNum => {
                const baseTime = Math.floor(Math.random() * 25) + 5;
                result[routeNum] = {
                    nextArrival: [baseTime, baseTime + 15, baseTime + 30],
                    status: 'æ­£å¸¸ç‡Ÿé‹'
                };
            });
            return result;
        }

        // è™•ç† TDX å…¬è»Š API å›æ‡‰è³‡æ–™
        function processBusData(routeNum, apiData) {
            if (apiData && apiData.length > 0) {
                const busInfo = apiData[0];
                const estimateTime = busInfo.EstimateTime;
                const stopStatus = busInfo.StopStatus;
                
                if (estimateTime !== undefined && estimateTime !== null) {
                    const minutes = Math.floor(estimateTime / 60);
                    BUS_ROUTES[routeNum].nextArrival = [minutes, minutes + 15, minutes + 30];
                } else if (stopStatus === 0) {
                    // StopStatus: 0=æ­£å¸¸, 1=å°šæœªç™¼è»Š, 2=äº¤ç®¡ä¸åœé , 3=æœ«ç­è»Šå·²é, 4=ä»Šæ—¥æœªç‡Ÿé‹
                    BUS_ROUTES[routeNum].nextArrival = ['å³å°‡åˆ°ç«™', 15, 30];
                } else {
                    BUS_ROUTES[routeNum].nextArrival = ['æŸ¥è©¢ä¸­', 0, 0];
                }
                
                // è¨­å®šç‡Ÿé‹ç‹€æ…‹
                switch(stopStatus) {
                    case 0:
                        BUS_ROUTES[routeNum].status = 'æ­£å¸¸ç‡Ÿé‹';
                        break;
                    case 1:
                        BUS_ROUTES[routeNum].status = 'å°šæœªç™¼è»Š';
                        break;
                    case 2:
                        BUS_ROUTES[routeNum].status = 'äº¤ç®¡ä¸åœé ';
                        break;
                    case 3:
                        BUS_ROUTES[routeNum].status = 'æœ«ç­è»Šå·²é';
                        break;
                    case 4:
                        BUS_ROUTES[routeNum].status = 'ä»Šæ—¥æœªç‡Ÿé‹';
                        break;
                    default:
                        BUS_ROUTES[routeNum].status = 'æ­£å¸¸ç‡Ÿé‹';
                }
            }
        }
        
        // æ›´æ–°å…¬è»Šé¡¯ç¤º
        function updateBusInfo() {
            const routes = document.querySelectorAll('.bus-route');
            routes.forEach((route, index) => {
                const routeNumbers = ['302', '69', '156'];
                const routeNum = routeNumbers[index];
                const arrivalSpan = route.querySelector('.arrival-time span');
                const statusElement = route.querySelector('.route-status');
                
                if (BUS_ROUTES[routeNum]) {
                    const nextTime = BUS_ROUTES[routeNum].nextArrival[0];
                    const routeStatus = BUS_ROUTES[routeNum].status || 'æ­£å¸¸ç‡Ÿé‹';
                    
                    // æ›´æ–°åˆ°ç«™æ™‚é–“
                    if (typeof nextTime === 'string') {
                        arrivalSpan.textContent = nextTime;
                    } else {
                        arrivalSpan.textContent = nextTime <= 0 ? 'å³å°‡åˆ°ç«™' : `${nextTime} åˆ†é˜`;
                    }
                    
                    arrivalSpan.classList.remove('loading');
                    
                    // æ›´æ–°ç‹€æ…‹æŒ‡ç¤ºå™¨
                    statusElement.textContent = routeStatus;
                    statusElement.classList.remove('delay');
                    statusElement.style.background = ''; // é‡ç½®èƒŒæ™¯è‰²
                    
                    // æ ¹æ“šç‹€æ…‹è¨­å®šæ¨£å¼
                    if (routeStatus === 'ç­æ¬¡å»¶èª¤' || routeStatus === 'äº¤ç®¡ä¸åœé ') {
                        statusElement.classList.add('delay');
                        statusElement.style.background = '#FF9800'; // æ©˜è‰²
                    } else if (routeStatus === 'æœ«ç­è»Šå·²é' || routeStatus === 'ä»Šæ—¥æœªç‡Ÿé‹') {
                        statusElement.style.background = '#f44336'; // ç´…è‰²
                    } else if (routeStatus === 'å°šæœªç™¼è»Š') {
                        statusElement.style.background = '#FF9800'; // æ©˜è‰²
                    } else {
                        statusElement.style.background = '#4CAF50'; // ç¶ è‰²
                    }
                    
                    // è‡ªå‹•åˆ¤æ–·å»¶èª¤ç‹€æ…‹
                    if (typeof nextTime === 'number' && nextTime > 25) {
                        statusElement.textContent = 'ç­æ¬¡å»¶èª¤';
                        statusElement.classList.add('delay');
                        statusElement.style.background = '#FF9800'; // æ©˜è‰²
                        BUS_ROUTES[routeNum].status = 'ç­æ¬¡å»¶èª¤';
                    }
                }
            });
        }


        // ç²å–å¤©æ°£è³‡è¨Š (å¤šé‡å‚™æ´)
        async function fetchWeatherData() {
            try {
                console.log('é–‹å§‹ç²å–å¤©æ°£è³‡è¨Š (å¤šé‡ä¾†æº)...');
                const result = await fetchWeatherWithFallback();
                if (result) {
                    weatherData = result;
                }
            } catch (error) {
                console.error('æ‰€æœ‰å¤©æ°£è³‡æ–™ä¾†æºå¤±æ•—:', error);
                weatherData = generateIntelligentWeather();
            }
        }

        // ä½¿ç”¨é–‹æ”¾çš„å¤©æ°£ API
        async function fetchWeatherFromOpenAPI() {
            try {
                // ä½¿ç”¨ OpenWeatherMap çš„æ›¿ä»£æ–¹æ¡ˆï¼ˆä¸éœ€è¦ API key çš„å…è²»æœå‹™ï¼‰
                // é€™è£¡ä½¿ç”¨ wttr.in ä½œç‚ºç¤ºç¯„
                const response = await fetch('https://wttr.in/Taichung?format=j1');
                
                if (response.ok) {
                    const data = await response.json();
                    const current = data.current_condition[0];
                    
                    weatherData = {
                        temperature: current.temp_C,
                        description: translateWeatherCode(current.weatherCode),
                        humidity: current.humidity,
                        windspeed: Math.round(current.windspeedKmph)
                    };
                } else {
                    throw new Error('å¤©æ°£ API å›æ‡‰å¤±æ•—');
                }
            } catch (error) {
                console.error('é–‹æ”¾å¤©æ°£ API å¤±æ•—:', error);
                generateMockWeatherData();
            }
        }

        // å¤©æ°£ä»£ç¢¼è½‰æ› (æ“´å±•ç‰ˆ)
        function translateWeatherCode(code) {
            const weatherCodes = {
                '113': 'æ™´å¤©', '116': 'å±€éƒ¨å¤šé›²', '119': 'å¤šé›²', '122': 'é™°å¤©',
                '143': 'éœ§', '176': 'å±€éƒ¨å°é›¨', '179': 'å±€éƒ¨é›¨å¤¾é›ª', '182': 'å±€éƒ¨é›¨å¤¾å†°é›¹',
                '185': 'å±€éƒ¨å‡é›¨', '200': 'é›·é™£é›¨', '227': 'å¹é›ª', '230': 'æš´é¢¨é›ª',
                '248': 'éœ§', '260': 'éœ§', '263': 'å°é›¨', '266': 'å°é›¨',
                '281': 'å‡é›¨', '284': 'é‡å‡é›¨', '293': 'å°é›¨', '296': 'å°é›¨',
                '299': 'ä¸­é›¨', '302': 'ä¸­é›¨', '305': 'å¤§é›¨', '308': 'å¤§é›¨',
                '311': 'å‡é›¨', '314': 'é‡å‡é›¨', '317': 'é›¨å¤¾å†°é›¹', '320': 'é›¨å¤¾é›ª',
                '323': 'é›ª', '326': 'é›ª', '329': 'å¤§é›ª', '332': 'å¤§é›ª',
                '335': 'å¤§é›ª', '338': 'å¤§é›ª', '350': 'å†°é›¹', '353': 'å°é›¨',
                '356': 'ä¸­é›¨', '359': 'å¤§é›¨', '362': 'é›¨å¤¾é›ª', '365': 'é›¨å¤¾é›ª',
                '368': 'é›¨å¤¾é›ª', '371': 'å¤§é›ª', '374': 'é›¨å¤¾å†°é›¹', '377': 'é›¨å¤¾å†°é›¹',
                '386': 'é›·é™£é›¨', '389': 'é›·é™£é›¨', '392': 'é›·é™£é›ª', '395': 'å¤§é›·é›ª'
            };
            return weatherCodes[code] || 'æœªçŸ¥å¤©æ°£';
        }

        // åœè»Šå ´è³‡è¨Š (æ™ºèƒ½æ¨¡æ“¬)
        async function fetchParkingInfo() {
            try {
                console.log('æ­£åœ¨ç²å–åœè»Šå ´è³‡è¨Š...');
                
                // æ¨¡æ“¬çœŸå¯¦çš„åœè»Šå ´è®ŠåŒ–é‚è¼¯
                const now = new Date();
                const hour = now.getHours();
                const minute = now.getMinutes();
                
                let baseSpaces = 300; // ç¸½è»Šä½å‡è¨­300å€‹
                
                // æ ¹æ“šæ™‚æ®µèª¿æ•´è»Šä½ä½¿ç”¨ç‡
                if (hour >= 6 && hour <= 8) { // æ—©ä¸Šå‡ºç™¼é«˜å³°
                    baseSpaces = Math.floor(baseSpaces * 0.4); // 60% ä½¿ç”¨ç‡
                } else if (hour >= 9 && hour <= 17) { // ç™½å¤©
                    baseSpaces = Math.floor(baseSpaces * 0.7); // 30% ä½¿ç”¨ç‡
                } else if (hour >= 18 && hour <= 21) { // æ™šä¸Šå›ç¨‹é«˜å³°
                    baseSpaces = Math.floor(baseSpaces * 0.3); // 70% ä½¿ç”¨ç‡
                } else { // æ·±å¤œ
                    baseSpaces = Math.floor(baseSpaces * 0.8); // 20% ä½¿ç”¨ç‡
                }
                
                // åŠ å…¥éš¨æ©Ÿè®Šå‹•
                const randomVariation = Math.floor((Math.random() - 0.5) * 50);
                const finalSpaces = Math.max(0, Math.min(300, baseSpaces + randomVariation));
                
                updateParkingDisplay(finalSpaces);
                
                // æ¨¡æ“¬å³å°‡æ»¿ä½çš„è­¦å‘Š
                if (finalSpaces < 20) {
                    console.warn('åœè»Šå ´å³å°‡æ»¿ä½ï¼');
                }
                
            } catch (error) {
                console.error('ç²å–åœè»Šå ´è³‡æ–™å¤±æ•—:', error);
                updateParkingDisplay(Math.floor(Math.random() * 100) + 150); // å‚™ç”¨éš¨æ©Ÿå€¼
            }
        }

        // äº¤é€šè·¯æ³æ¨¡æ“¬
        function updateTrafficInfo() {
            const trafficItems = document.querySelectorAll('.traffic-item');
            
            if (trafficItems.length >= 2) {
                const roadStatus = ['è»Šæµé †æš¢', 'è»Šæµç·©æ…¢', 'è¼•å¾®å£…å¡', 'è»Šæµæ­£å¸¸'];
                const highway61Status = ['è»Šæµæ­£å¸¸', 'è»Šé€Ÿè¼ƒæ…¢', 'è»Šæµé †æš¢', 'æ–½å·¥ç®¡åˆ¶'];
                
                // ä¸­æ¸…è·¯æ®µ
                const roadText = roadStatus[Math.floor(Math.random() * roadStatus.length)];
                trafficItems[1].querySelector('div:last-child').textContent = roadText;
                
                // å°61ç·š
                const highwayText = highway61Status[Math.floor(Math.random() * highway61Status.length)];
                trafficItems[2].querySelector('div:last-child').textContent = highwayText;
            }
        }

        // æ›´æ–°åœè»Šå ´é¡¯ç¤º
        function updateParkingDisplay(spaces) {
            const parkingElement = document.querySelector('.traffic-item:first-child div:last-child');
            if (parkingElement) {
                parkingElement.innerHTML = `å‰©é¤˜è»Šä½ï¼š<span class="blinking" style="color: #FFD700;">${spaces}</span> ä½`;
            }
        }

        // æ›´æ–°å¤©æ°£è³‡è¨Š
        function updateWeatherInfo() {
            document.getElementById('temperature').textContent = `${weatherData.temperature}Â°C`;
            document.getElementById('weather-desc').textContent = weatherData.description;
            document.getElementById('humidity').textContent = weatherData.humidity;
            document.getElementById('windspeed').textContent = weatherData.windspeed;
            document.getElementById('quick-weather').textContent = `${weatherData.temperature}Â°C ${weatherData.description}`;
        }

        // æ›´æ–°æœ€å¾Œæ›´æ–°æ™‚é–“
        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('last-update').textContent = now.toLocaleTimeString('zh-TW', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        // æ›´æ–°æ‰€æœ‰å³æ™‚è³‡æ–™
        async function updateAllRealTimeData() {
            console.log('æ›´æ–°æ‰€æœ‰å³æ™‚è³‡æ–™...');
            
            try {
                // ä¸¦è¡Œæ›´æ–°æ‰€æœ‰è³‡æ–™
                await Promise.allSettled([
                    fetchBusRealTime(),
                    fetchWeatherData(),
                    fetchParkingInfo(),
                    updateTrafficInfo()
                ]);
                
                // æ›´æ–°é¡¯ç¤º
                updateBusInfo();
                updateWeatherInfo();
                updateLastUpdateTime();
                
                console.log('è³‡æ–™æ›´æ–°å®Œæˆ');
            } catch (error) {
                console.error('è³‡æ–™æ›´æ–°å¤±æ•—:', error);
            }
        }
        
        // åˆå§‹åŒ–æ‰€æœ‰è³‡æ–™
        async function initializeData() {
            console.log('åˆå§‹åŒ–ç³»çµ±è³‡æ–™...');
            
            // åŒæ™‚è¼‰å…¥æ‰€æœ‰è³‡æ–™
            await updateAllRealTimeData();
        }

        // åˆå§‹åŒ–
        function init() {
            updateDateTime();
            initializeData(); // éåŒæ­¥åˆå§‹åŒ–
        }

        // å®šæ™‚æ›´æ–°
        setInterval(updateDateTime, 1000);              // æ¯ç§’æ›´æ–°æ™‚é–“
        setInterval(updateAllRealTimeData, 60000);      // æ¯1åˆ†é˜æ›´æ–°æ‰€æœ‰å³æ™‚è³‡æ–™

        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        window.onload = init;
    </script>
</body>
</html>