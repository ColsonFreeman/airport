<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台中機場交通資訊系統</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .datetime-weather {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5em;
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            padding: 30px;
            min-height: calc(100vh - 200px);
        }

        .bus-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .bus-section h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-align: center;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .bus-route {
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
            padding: 25px;
            border-radius: 15px;
            border-left: 5px solid #FFD700;
            transition: transform 0.3s ease;
        }

        .bus-route:hover {
            transform: translateX(10px);
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .route-number {
            font-size: 2.2em;
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .route-status {
            font-size: 1.3em;
            padding: 8px 15px;
            border-radius: 20px;
            background: #4CAF50;
            color: white;
        }

        .route-status.delay {
            background: #FF9800;
        }

        .route-info {
            font-size: 1.4em;
            margin: 10px 0;
        }

        .arrival-time {
            font-size: 1.8em;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .weather-panel, .traffic-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            color: #87CEEB;
        }

        .weather-info {
            text-align: center;
            font-size: 1.4em;
        }

        .temperature {
            font-size: 3em;
            font-weight: bold;
            color: #FFD700;
            margin: 20px 0;
        }

        .traffic-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #87CEEB;
        }

        .update-time {
            text-align: center;
            margin-top: 20px;
            font-size: 1.1em;
            color: #B0C4DE;
        }

        .blinking {
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .loading {
            color: #FFD700;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>台中機場交通資訊系統</h1>
        <div class="datetime-weather">
            <div id="datetime"></div>
            <div id="quick-weather"></div>
        </div>
    </div>

    <div class="main-content">
        <div class="bus-section">
            <h2>🚌 公車即時資訊</h2>
            <div id="bus-routes">
                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">302</div>
                        <div class="route-status">正常營運</div>
                    </div>
                    <div class="route-info">台中機場 ↔ 台中車站</div>
                    <div class="arrival-time">預估到站：<span class="loading">載入中...</span></div>
                </div>

                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">69</div>
                        <div class="route-status">正常營運</div>
                    </div>
                    <div class="route-info">台中機場 ↔ 台中高鐵站</div>
                    <div class="arrival-time">預估到站：<span class="loading">載入中...</span></div>
                </div>

                <div class="bus-route">
                    <div class="route-header">
                        <div class="route-number">156</div>
                        <div class="route-status delay">班次延誤</div>
                    </div>
                    <div class="route-info">台中機場 ↔ 沙鹿火車站</div>
                    <div class="arrival-time">預估到站：<span class="loading">載入中...</span></div>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="weather-panel">
                <div class="panel-title">🌤️ 天氣資訊</div>
                <div class="weather-info">
                    <div>台中清水區</div>
                    <div class="temperature"><span id="temperature">載入中...</span></div>
                    <div id="weather-desc">載入天氣資訊中...</div>
                    <div>濕度：<span id="humidity">--</span>%</div>
                    <div>風速：<span id="windspeed">--</span> km/h</div>
                </div>
            </div>

            <div class="traffic-panel">
                <div class="panel-title">🚗 交通資訊</div>
                <div class="traffic-item">
                    <div><strong>機場停車場</strong></div>
                    <div>剩餘車位：<span class="blinking" style="color: #FFD700;">235</span> 位</div>
                </div>
                <div class="traffic-item">
                    <div><strong>中清路段</strong></div>
                    <div>車流順暢</div>
                </div>
                <div class="traffic-item">
                    <div><strong>台61線</strong></div>
                    <div>車流正常</div>
                </div>
                <div class="traffic-item">
                    <div><strong>計程車服務</strong></div>
                    <div style="color: #4CAF50;">正常營運中</div>
                </div>
            </div>
        </div>
    </div>

    <div class="update-time">
        最後更新：<span id="last-update"></span>
    </div>

    <script>
        // API 替代方案設定
        const DATA_SOURCES = {
            // 方案1: TDX API (需要認證)
            TDX_API: {
                enabled: false, // 需要 API Key 時設為 true
                baseUrl: 'https://tdx.transportdata.tw/api/basic/v2',
                appId: 'YOUR_TDX_APP_ID',
                appKey: 'YOUR_TDX_APP_KEY'
            },
            
            // 方案2: 網頁爬蟲 (透過代理服務器)
            WEB_SCRAPING: {
                enabled: false, // 需要後端服務時設為 true
                proxyUrl: '/api/scrape-bus', // 您的後端 API
                sources: {
                    taichungBus: 'https://www.tcbus.com.tw/api/realtime',
                    ibus: 'https://ibus.gov.tw/api/RealTime'
                }
            },
            
            // 方案3: 靜態資料檔 (GTFS)
            STATIC_DATA: {
                enabled: true, // 預設啟用
                gtfsUrl: '/data/taichung-gtfs.json', // 本地或 CDN 的靜態檔案
                lastUpdate: null,
                updateInterval: 300000 // 5分鐘更新一次
            },
            
            // 方案4: 免費第三方 API
            FREE_APIS: {
                enabled: true, // 預設啟用
                sources: {
                    openWeather: 'https://api.openweathermap.org/data/2.5/weather',
                    wttr: 'https://wttr.in',
                    jsonp: 'https://api.jsonp.afeld.me/?url=' // JSONP 代理
                }
            },
            
            // 方案5: 本地模擬 (備用方案)
            MOCK_DATA: {
                enabled: true,
                realistic: true // 使用真實的變動邏輯
            }
        };

        // 公車路線設定 (TDX 格式)
        const BUS_ROUTES = {
            '302': { 
                routeName: '302', 
                destination: '台中車站',
                stopId: '18958', // 台中機場站牌ID
                nextArrival: [0, 0, 0],
                status: '正常營運'
            },
            '69': { 
                routeName: '69', 
                destination: '台中高鐵站',
                stopId: '18958',
                nextArrival: [0, 0, 0],
                status: '正常營運'
            },
            '156': { 
                routeName: '156', 
                destination: '沙鹿火車站',
                stopId: '18958',
                nextArrival: [0, 0, 0],
                status: '正常營運'
            }
        };

        // 天氣數據
        let weatherData = {
            temperature: '--',
            description: '載入中...',
            humidity: '--',
            windspeed: '--'
        };

        // 更新日期時間
        function updateDateTime() {
            const now = new Date();
            const options = {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                weekday: 'short',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };
            document.getElementById('datetime').textContent = now.toLocaleDateString('zh-TW', options);
        }

        // 方案1: 使用 JSONP 代理抓取資料
        async function fetchDataWithJSONP(url) {
            try {
                const proxyUrl = DATA_SOURCES.FREE_APIS.sources.jsonp + encodeURIComponent(url);
                const response = await fetch(proxyUrl);
                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('JSONP 代理失敗:', error);
                return null;
            }
        }

        // 方案2: 網頁爬蟲 (透過後端 API)
        async function fetchBusDataByScraping() {
            if (!DATA_SOURCES.WEB_SCRAPING.enabled) return null;
            
            try {
                console.log('使用網頁爬蟲獲取公車資料...');
                
                // 呼叫您的後端爬蟲 API
                const response = await fetch(DATA_SOURCES.WEB_SCRAPING.proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        routes: ['302', '69', '156'],
                        stop: '台中機場'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.busData;
                }
            } catch (error) {
                console.error('爬蟲 API 失敗:', error);
                return null;
            }
        }

        // 方案3: 載入靜態 GTFS 資料
        async function loadStaticBusData() {
            if (!DATA_SOURCES.STATIC_DATA.enabled) return null;
            
            try {
                console.log('載入靜態公車資料...');
                
                // 檢查是否需要更新
                const now = Date.now();
                const lastUpdate = DATA_SOURCES.STATIC_DATA.lastUpdate;
                const interval = DATA_SOURCES.STATIC_DATA.updateInterval;
                
                if (lastUpdate && (now - lastUpdate) < interval) {
                    return null; // 資料還很新，不需要更新
                }
                
                const response = await fetch(DATA_SOURCES.STATIC_DATA.gtfsUrl);
                if (response.ok) {
                    const gtfsData = await response.json();
                    DATA_SOURCES.STATIC_DATA.lastUpdate = now;
                    return processGTFSData(gtfsData);
                }
            } catch (error) {
                console.error('載入靜態資料失敗:', error);
                return null;
            }
        }

        // 處理 GTFS 格式資料
        function processGTFSData(gtfsData) {
            // GTFS 資料處理邏輯
            const processedData = {};
            
            if (gtfsData.routes) {
                gtfsData.routes.forEach(route => {
                    if (['302', '69', '156'].includes(route.route_short_name)) {
                        processedData[route.route_short_name] = {
                            nextArrival: generateRealisticArrival(),
                            status: '正常營運'
                        };
                    }
                });
            }
            
            return processedData;
        }

        // 方案4: 使用免費天氣 API (多重備援)
        async function fetchWeatherWithFallback() {
            const weatherSources = [
                // 來源1: wttr.in (免費，無需 API Key)
                async () => {
                    const response = await fetch('https://wttr.in/Taichung?format=j1');
                    if (response.ok) {
                        const data = await response.json();
                        const current = data.current_condition[0];
                        return {
                            temperature: current.temp_C,
                            description: translateWeatherCode(current.weatherCode),
                            humidity: current.humidity,
                            windspeed: Math.round(current.windspeedKmph),
                            source: 'wttr.in'
                        };
                    }
                    throw new Error('wttr.in 失敗');
                },
                
                // 來源2: OpenWeatherMap 免費方案 (需要 API Key，但有免費配額)
                async () => {
                    // 如果有 OpenWeather API Key 可以使用這個
                    const apiKey = 'YOUR_OPENWEATHER_KEY'; // 請替換
                    if (apiKey === 'YOUR_OPENWEATHER_KEY') throw new Error('無 API Key');
                    
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=Taichung&appid=${apiKey}&units=metric&lang=zh_tw`);
                    if (response.ok) {
                        const data = await response.json();
                        return {
                            temperature: Math.round(data.main.temp),
                            description: data.weather[0].description,
                            humidity: data.main.humidity,
                            windspeed: Math.round(data.wind.speed * 3.6), // m/s 轉 km/h
                            source: 'OpenWeatherMap'
                        };
                    }
                    throw new Error('OpenWeatherMap 失敗');
                },
                
                // 來源3: 智能模擬 (基於時間和季節的邏輯)
                async () => {
                    return generateIntelligentWeather();
                }
            ];
            
            // 依序嘗試各種來源
            for (let i = 0; i < weatherSources.length; i++) {
                try {
                    const result = await weatherSources[i]();
                    console.log(`天氣資料來源: ${result.source || '模擬資料'}`);
                    return result;
                } catch (error) {
                    console.warn(`天氣來源 ${i + 1} 失敗:`, error.message);
                    if (i === weatherSources.length - 1) {
                        // 最後一個來源也失敗，返回模擬資料
                        return generateIntelligentWeather();
                    }
                }
            }
        }

        // 智能天氣模擬 (基於真實邏輯)
        function generateIntelligentWeather() {
            const now = new Date();
            const hour = now.getHours();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            
            // 基於台中季節特色的溫度
            let baseTemp;
            if (month >= 3 && month <= 5) { // 春季
                baseTemp = 22 + Math.random() * 6;
            } else if (month >= 6 && month <= 8) { // 夏季
                baseTemp = 28 + Math.random() * 6;
            } else if (month >= 9 && month <= 11) { // 秋季
                baseTemp = 24 + Math.random() * 6;
            } else { // 冬季
                baseTemp = 18 + Math.random() * 6;
            }
            
            // 日夜溫差
            if (hour >= 6 && hour <= 18) {
                baseTemp += 2; // 白天較暖
            } else {
                baseTemp -= 2; // 夜晚較涼
            }
            
            // 天氣描述 (基於季節)
            const seasonWeather = {
                spring: ['晴天', '多雲', '局部多雲', '春雨'],
                summer: ['晴天', '午後雷陣雨', '多雲時晴', '炎熱'],
                autumn: ['秋高氣爽', '多雲', '晴天', '涼爽'],
                winter: ['多雲', '晴天', '東北季風', '涼冷']
            };
            
            const currentSeason = month >= 3 && month <= 5 ? 'spring' :
                                 month >= 6 && month <= 8 ? 'summer' :
                                 month >= 9 && month <= 11 ? 'autumn' : 'winter';
            
            const descriptions = seasonWeather[currentSeason];
            const randomDesc = descriptions[Math.floor(Math.random() * descriptions.length)];
            
            return {
                temperature: Math.round(baseTemp),
                description: randomDesc,
                humidity: Math.floor(Math.random() * 30) + 50,
                windspeed: Math.floor(Math.random() * 15) + 5,
                source: '智能模擬'
            };
        }

        // 生成真實的公車到站時間
        function generateRealisticArrival() {
            const now = new Date();
            const hour = now.getHours();
            const minute = now.getMinutes();
            
            let baseTime;
            
            // 根據時段調整班次頻率
            if (hour >= 6 && hour <= 9) { // 上班尖峰
                baseTime = Math.floor(Math.random() * 8) + 3; // 3-10分鐘
            } else if (hour >= 17 && hour <= 19) { // 下班尖峰
                baseTime = Math.floor(Math.random() * 8) + 3; // 3-10分鐘
            } else if (hour >= 10 && hour <= 16) { // 白天離峰
                baseTime = Math.floor(Math.random() * 15) + 8; // 8-22分鐘
            } else if (hour >= 20 && hour <= 23) { // 晚上
                baseTime = Math.floor(Math.random() * 20) + 10; // 10-29分鐘
            } else { // 深夜/清晨
                baseTime = Math.floor(Math.random() * 40) + 20; // 20-59分鐘
            }
            
            return [baseTime, baseTime + 15, baseTime + 30];
        }

        // 智能資料獲取 (多重備援策略)
        async function fetchBusRealTime() {
            console.log('開始獲取公車資料 (多重來源)...');
            
            const dataSources = [
                // 優先順序1: TDX API (如果有設定)
                async () => {
                    if (!DATA_SOURCES.TDX_API.enabled) throw new Error('TDX API 未啟用');
                    return await fetchFromTDXAPI();
                },
                
                // 優先順序2: 網頁爬蟲
                async () => {
                    if (!DATA_SOURCES.WEB_SCRAPING.enabled) throw new Error('爬蟲未啟用');
                    return await fetchBusDataByScraping();
                },
                
                // 優先順序3: 靜態 GTFS 資料
                async () => {
                    if (!DATA_SOURCES.STATIC_DATA.enabled) throw new Error('靜態資料未啟用');
                    return await loadStaticBusData();
                },
                
                // 優先順序4: 智能模擬 (永遠可用)
                async () => {
                    return generateIntelligentBusData();
                }
            ];
            
            // 依序嘗試各種資料來源
            for (let i = 0; i < dataSources.length; i++) {
                try {
                    const result = await dataSources[i]();
                    if (result) {
                        // 更新 BUS_ROUTES 資料
                        Object.keys(result).forEach(routeNum => {
                            if (BUS_ROUTES[routeNum]) {
                                BUS_ROUTES[routeNum].nextArrival = result[routeNum].nextArrival;
                                BUS_ROUTES[routeNum].status = result[routeNum].status || '正常營運';
                            }
                        });
                        
                        console.log(`公車資料來源: ${getSourceName(i)}`);
                        return result;
                    }
                } catch (error) {
                    console.warn(`公車資料來源 ${i + 1} 失敗:`, error.message);
                }
            }
            
            // 如果所有來源都失敗，使用基本模擬
            console.warn('所有公車資料來源失敗，使用基本模擬');
            return generateBasicBusData();
        }

        // 獲取來源名稱
        function getSourceName(index) {
            const names = ['TDX API', '網頁爬蟲', '靜態資料', '智能模擬'];
            return names[index] || '未知來源';
        }

        // TDX API 調用 (如果有設定)
        async function fetchFromTDXAPI() {
            // 這裡是之前的 TDX API 程式碼
            // 由於需要認證，暫時跳過
            throw new Error('TDX API 需要認證設定');
        }

        // 智能模擬公車資料
        function generateIntelligentBusData() {
            const result = {};
            
            Object.keys(BUS_ROUTES).forEach(routeNum => {
                const arrivalTimes = generateRealisticArrival();
                
                // 基於路線特性調整
                let status = '正常營運';
                const firstArrival = arrivalTimes[0];
                
                if (firstArrival > 30) {
                    status = '班次延誤';
                } else if (firstArrival < 2) {
                    status = '即將到站';
                }
                
                // 特殊情況模擬
                const now = new Date();
                if (now.getHours() < 5 || now.getHours() > 23) {
                    status = '夜間減班';
                    arrivalTimes[0] = Math.floor(Math.random() * 30) + 30; // 30-59分鐘
                }
                
                result[routeNum] = {
                    nextArrival: arrivalTimes,
                    status: status
                };
            });
            
            return result;
        }

        // 基本模擬資料 (最後備案)
        function generateBasicBusData() {
            const result = {};
            Object.keys(BUS_ROUTES).forEach(routeNum => {
                const baseTime = Math.floor(Math.random() * 25) + 5;
                result[routeNum] = {
                    nextArrival: [baseTime, baseTime + 15, baseTime + 30],
                    status: '正常營運'
                };
            });
            return result;
        }

        // 處理 TDX 公車 API 回應資料
        function processBusData(routeNum, apiData) {
            if (apiData && apiData.length > 0) {
                const busInfo = apiData[0];
                const estimateTime = busInfo.EstimateTime;
                const stopStatus = busInfo.StopStatus;
                
                if (estimateTime !== undefined && estimateTime !== null) {
                    const minutes = Math.floor(estimateTime / 60);
                    BUS_ROUTES[routeNum].nextArrival = [minutes, minutes + 15, minutes + 30];
                } else if (stopStatus === 0) {
                    // StopStatus: 0=正常, 1=尚未發車, 2=交管不停靠, 3=末班車已過, 4=今日未營運
                    BUS_ROUTES[routeNum].nextArrival = ['即將到站', 15, 30];
                } else {
                    BUS_ROUTES[routeNum].nextArrival = ['查詢中', 0, 0];
                }
                
                // 設定營運狀態
                switch(stopStatus) {
                    case 0:
                        BUS_ROUTES[routeNum].status = '正常營運';
                        break;
                    case 1:
                        BUS_ROUTES[routeNum].status = '尚未發車';
                        break;
                    case 2:
                        BUS_ROUTES[routeNum].status = '交管不停靠';
                        break;
                    case 3:
                        BUS_ROUTES[routeNum].status = '末班車已過';
                        break;
                    case 4:
                        BUS_ROUTES[routeNum].status = '今日未營運';
                        break;
                    default:
                        BUS_ROUTES[routeNum].status = '正常營運';
                }
            }
        }
        
        // 更新公車顯示
        function updateBusInfo() {
            const routes = document.querySelectorAll('.bus-route');
            routes.forEach((route, index) => {
                const routeNumbers = ['302', '69', '156'];
                const routeNum = routeNumbers[index];
                const arrivalSpan = route.querySelector('.arrival-time span');
                const statusElement = route.querySelector('.route-status');
                
                if (BUS_ROUTES[routeNum]) {
                    const nextTime = BUS_ROUTES[routeNum].nextArrival[0];
                    const routeStatus = BUS_ROUTES[routeNum].status || '正常營運';
                    
                    // 更新到站時間
                    if (typeof nextTime === 'string') {
                        arrivalSpan.textContent = nextTime;
                    } else {
                        arrivalSpan.textContent = nextTime <= 0 ? '即將到站' : `${nextTime} 分鐘`;
                    }
                    
                    arrivalSpan.classList.remove('loading');
                    
                    // 更新狀態指示器
                    statusElement.textContent = routeStatus;
                    statusElement.classList.remove('delay');
                    statusElement.style.background = ''; // 重置背景色
                    
                    // 根據狀態設定樣式
                    if (routeStatus === '班次延誤' || routeStatus === '交管不停靠') {
                        statusElement.classList.add('delay');
                        statusElement.style.background = '#FF9800'; // 橘色
                    } else if (routeStatus === '末班車已過' || routeStatus === '今日未營運') {
                        statusElement.style.background = '#f44336'; // 紅色
                    } else if (routeStatus === '尚未發車') {
                        statusElement.style.background = '#FF9800'; // 橘色
                    } else {
                        statusElement.style.background = '#4CAF50'; // 綠色
                    }
                    
                    // 自動判斷延誤狀態
                    if (typeof nextTime === 'number' && nextTime > 25) {
                        statusElement.textContent = '班次延誤';
                        statusElement.classList.add('delay');
                        statusElement.style.background = '#FF9800'; // 橘色
                        BUS_ROUTES[routeNum].status = '班次延誤';
                    }
                }
            });
        }


        // 獲取天氣資訊 (多重備援)
        async function fetchWeatherData() {
            try {
                console.log('開始獲取天氣資訊 (多重來源)...');
                const result = await fetchWeatherWithFallback();
                if (result) {
                    weatherData = result;
                }
            } catch (error) {
                console.error('所有天氣資料來源失敗:', error);
                weatherData = generateIntelligentWeather();
            }
        }

        // 使用開放的天氣 API
        async function fetchWeatherFromOpenAPI() {
            try {
                // 使用 OpenWeatherMap 的替代方案（不需要 API key 的免費服務）
                // 這裡使用 wttr.in 作為示範
                const response = await fetch('https://wttr.in/Taichung?format=j1');
                
                if (response.ok) {
                    const data = await response.json();
                    const current = data.current_condition[0];
                    
                    weatherData = {
                        temperature: current.temp_C,
                        description: translateWeatherCode(current.weatherCode),
                        humidity: current.humidity,
                        windspeed: Math.round(current.windspeedKmph)
                    };
                } else {
                    throw new Error('天氣 API 回應失敗');
                }
            } catch (error) {
                console.error('開放天氣 API 失敗:', error);
                generateMockWeatherData();
            }
        }

        // 天氣代碼轉換 (擴展版)
        function translateWeatherCode(code) {
            const weatherCodes = {
                '113': '晴天', '116': '局部多雲', '119': '多雲', '122': '陰天',
                '143': '霧', '176': '局部小雨', '179': '局部雨夾雪', '182': '局部雨夾冰雹',
                '185': '局部凍雨', '200': '雷陣雨', '227': '吹雪', '230': '暴風雪',
                '248': '霧', '260': '霧', '263': '小雨', '266': '小雨',
                '281': '凍雨', '284': '重凍雨', '293': '小雨', '296': '小雨',
                '299': '中雨', '302': '中雨', '305': '大雨', '308': '大雨',
                '311': '凍雨', '314': '重凍雨', '317': '雨夾冰雹', '320': '雨夾雪',
                '323': '雪', '326': '雪', '329': '大雪', '332': '大雪',
                '335': '大雪', '338': '大雪', '350': '冰雹', '353': '小雨',
                '356': '中雨', '359': '大雨', '362': '雨夾雪', '365': '雨夾雪',
                '368': '雨夾雪', '371': '大雪', '374': '雨夾冰雹', '377': '雨夾冰雹',
                '386': '雷陣雨', '389': '雷陣雨', '392': '雷陣雪', '395': '大雷雪'
            };
            return weatherCodes[code] || '未知天氣';
        }

        // 停車場資訊 (智能模擬)
        async function fetchParkingInfo() {
            try {
                console.log('正在獲取停車場資訊...');
                
                // 模擬真實的停車場變化邏輯
                const now = new Date();
                const hour = now.getHours();
                const minute = now.getMinutes();
                
                let baseSpaces = 300; // 總車位假設300個
                
                // 根據時段調整車位使用率
                if (hour >= 6 && hour <= 8) { // 早上出發高峰
                    baseSpaces = Math.floor(baseSpaces * 0.4); // 60% 使用率
                } else if (hour >= 9 && hour <= 17) { // 白天
                    baseSpaces = Math.floor(baseSpaces * 0.7); // 30% 使用率
                } else if (hour >= 18 && hour <= 21) { // 晚上回程高峰
                    baseSpaces = Math.floor(baseSpaces * 0.3); // 70% 使用率
                } else { // 深夜
                    baseSpaces = Math.floor(baseSpaces * 0.8); // 20% 使用率
                }
                
                // 加入隨機變動
                const randomVariation = Math.floor((Math.random() - 0.5) * 50);
                const finalSpaces = Math.max(0, Math.min(300, baseSpaces + randomVariation));
                
                updateParkingDisplay(finalSpaces);
                
                // 模擬即將滿位的警告
                if (finalSpaces < 20) {
                    console.warn('停車場即將滿位！');
                }
                
            } catch (error) {
                console.error('獲取停車場資料失敗:', error);
                updateParkingDisplay(Math.floor(Math.random() * 100) + 150); // 備用隨機值
            }
        }

        // 交通路況模擬
        function updateTrafficInfo() {
            const trafficItems = document.querySelectorAll('.traffic-item');
            
            if (trafficItems.length >= 2) {
                const roadStatus = ['車流順暢', '車流緩慢', '輕微壅塞', '車流正常'];
                const highway61Status = ['車流正常', '車速較慢', '車流順暢', '施工管制'];
                
                // 中清路段
                const roadText = roadStatus[Math.floor(Math.random() * roadStatus.length)];
                trafficItems[1].querySelector('div:last-child').textContent = roadText;
                
                // 台61線
                const highwayText = highway61Status[Math.floor(Math.random() * highway61Status.length)];
                trafficItems[2].querySelector('div:last-child').textContent = highwayText;
            }
        }

        // 更新停車場顯示
        function updateParkingDisplay(spaces) {
            const parkingElement = document.querySelector('.traffic-item:first-child div:last-child');
            if (parkingElement) {
                parkingElement.innerHTML = `剩餘車位：<span class="blinking" style="color: #FFD700;">${spaces}</span> 位`;
            }
        }

        // 更新天氣資訊
        function updateWeatherInfo() {
            document.getElementById('temperature').textContent = `${weatherData.temperature}°C`;
            document.getElementById('weather-desc').textContent = weatherData.description;
            document.getElementById('humidity').textContent = weatherData.humidity;
            document.getElementById('windspeed').textContent = weatherData.windspeed;
            document.getElementById('quick-weather').textContent = `${weatherData.temperature}°C ${weatherData.description}`;
        }

        // 更新最後更新時間
        function updateLastUpdateTime() {
            const now = new Date();
            document.getElementById('last-update').textContent = now.toLocaleTimeString('zh-TW', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        // 更新所有即時資料
        async function updateAllRealTimeData() {
            console.log('更新所有即時資料...');
            
            try {
                // 並行更新所有資料
                await Promise.allSettled([
                    fetchBusRealTime(),
                    fetchWeatherData(),
                    fetchParkingInfo(),
                    updateTrafficInfo()
                ]);
                
                // 更新顯示
                updateBusInfo();
                updateWeatherInfo();
                updateLastUpdateTime();
                
                console.log('資料更新完成');
            } catch (error) {
                console.error('資料更新失敗:', error);
            }
        }
        
        // 初始化所有資料
        async function initializeData() {
            console.log('初始化系統資料...');
            
            // 同時載入所有資料
            await updateAllRealTimeData();
        }

        // 初始化
        function init() {
            updateDateTime();
            initializeData(); // 非同步初始化
        }

        // 定時更新
        setInterval(updateDateTime, 1000);              // 每秒更新時間
        setInterval(updateAllRealTimeData, 60000);      // 每1分鐘更新所有即時資料

        // 頁面載入時初始化
        window.onload = init;
    </script>
</body>
</html>